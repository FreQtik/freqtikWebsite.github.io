<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>UFO Clicker</title>
  <style>
    html, body {
      margin: 0; padding: 0;
      overflow: hidden;
      font-family: Arial, sans-serif;
      background: black; color: white;
    }
    #gameCanvas { display: block; background: #000; }
    #hud {
      position: absolute; top: 10px; left: 10px; z-index: 10;
    }
    #muteBtn {
      position: absolute; top: 10px; right: 10px;
      background: none; color: white;
      border: 2px solid white; padding: 5px 10px;
      cursor: pointer;
    }
    #overlay, #analysisPanel {
      position: absolute; top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0,0,0,0.85);
      display: flex; align-items: center; justify-content: center;
      color: white; font-size: 20px; flex-direction: column;
      z-index: 20;
    }
    #overlay button, #analysisPanel button {
      margin-top: 20px; padding: 10px 20px; font-size: 16px;
    }
    #analysisPanel { display: none; }
    #chartContainer {
      width: 90%; max-width: 500px; margin-top: 20px;
    }
  </style>
</head>
<body>

<canvas id="gameCanvas"></canvas>

<div id="hud">
  Time: <span id="timeLeft">15.0</span>sÂ Â |Â Â Score: <span id="score">0</span>
</div>
<button id="muteBtn">ðŸ”Š</button>

<div id="overlay">
  <div>ðŸš€ Tap or Swipe UFOs before they escape!</div>
  <div>ðŸ‘¹ Boss (3 clicks) every minuteâ€”survive!</div>
  <button onclick="startGame()">Start Game</button>
</div>

<div id="analysisPanel">
  <h2>Game Over</h2>
  <p id="statsText"></p>
  <div id="chartContainer">
    <canvas id="reactionChart"></canvas>
  </div>
  <button onclick="startGame()">Play Again</button>
  <button onclick="quitToHome()">Quit to Home</button>
</div>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
const canvas = document.getElementById("gameCanvas"),
      ctx = canvas.getContext("2d");
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const hudTime = document.getElementById("timeLeft"),
      hudScore = document.getElementById("score"),
      overlay = document.getElementById("overlay"),
      analysis = document.getElementById("analysisPanel"),
      statsTxt = document.getElementById("statsText");

document.getElementById("muteBtn").onclick = toggleMute;
let isMuted = false;

function toggleMute() {
  isMuted = !isMuted;
  document.getElementById("muteBtn").innerText = isMuted ? "ðŸ”‡" : "ðŸ”Š";
}

let ufos = [], effects = [], score = 0, timeLeft = 15.0, lastTime = 0;
let spawnTimer = 0, nextBossAt = 60;
let reactionTimes = [];

const ufoSrc = ["ufos/ufo1.png","ufos/ufo2.png","ufos/ufo3.png"],
      bossSrc = "ufos/boss.png";

class UFO {
  constructor(x, y, vx, vy, isBoss = false, isMini = false) {
    this.x = x;
    this.y = y;
    this.vx = vx;
    this.vy = vy;
    this.size = isBoss ? 120 : isMini ? 40 : 64;
    this.hp = isBoss ? 3 : 1;
    this.isBoss = isBoss;
    this.isMini = isMini;
    this.movementType = Math.floor(Math.random() * 3); // 0: straight, 1: wave, 2: zigzag
    this.spawnTime = performance.now();
    this.img = new Image();
    this.img.src = isBoss ? bossSrc : ufoSrc[Math.floor(Math.random() * ufoSrc.length)];
    this.waveOffset = Math.random() * 2 * Math.PI;
  }

  update(dt) {
    if (this.movementType === 1) {
      this.y += this.vy;
      this.x += Math.sin(performance.now() * 0.003 + this.waveOffset) * 3;
    } else if (this.movementType === 2) {
      this.x += this.vx + Math.sin(performance.now() * 0.005 + this.waveOffset) * 2;
      this.y += this.vy + Math.cos(performance.now() * 0.005 + this.waveOffset) * 2;
    } else {
      this.x += this.vx;
      this.y += this.vy;
    }

    if (this.x < this.size/2 || this.x > canvas.width - this.size/2) this.vx *= -1;
    if (this.y < this.size/2 || this.y > canvas.height - this.size/2) this.vy *= -1;
  }

  draw() {
    ctx.drawImage(this.img, this.x - this.size/2, this.y - this.size/2, this.size, this.size);
  }

  hit(mx, my) {
    return Math.hypot(mx - this.x, my - this.y) < this.size / 2;
  }
}

class Effect {
  constructor(x,y) { this.x=x; this.y=y; this.r=0; this.a=1; }
  update() { this.r+=4; this.a-=0.07; }
  draw() {
    ctx.save();
    ctx.globalAlpha = this.a;
    ctx.strokeStyle = "yellow";
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.arc(this.x,this.y,this.r,0,Math.PI*2);
    ctx.stroke();
    ctx.restore();
  }
}

function spawnChain(isBoss = false) {
  const count = isBoss ? 1 : Math.floor(5 + Math.random() * 5);
  const spacing = 60;
  const startX = Math.random() * (canvas.width - spacing * count);
  const startY = Math.random() * (canvas.height - 100);
  const angle = Math.random() * 2 * Math.PI;
  const speed = 1 + spawnTimer * 0.002;

  for (let i = 0; i < count; i++) {
    const x = startX + i * Math.cos(angle) * spacing;
    const y = startY + i * Math.sin(angle) * spacing;
    const vx = Math.cos(angle) * speed;
    const vy = Math.sin(angle) * speed;
    ufos.push(new UFO(x, y, vx, vy, isBoss));
  }
}

function handleClick(cx, cy) {
  const rect = canvas.getBoundingClientRect(),
        mx = cx - rect.left,
        my = cy - rect.top;
  for (let i = ufos.length - 1; i >= 0; i--) {
    let u = ufos[i];
    if (u.hit(mx, my)) {
      u.hp--;
      effects.push(new Effect(mx, my));
      if (u.hp <= 0) {
        reactionTimes.push(performance.now() - u.spawnTime);
        ufos.splice(i, 1);
        score++;
        timeLeft += 0.5;

        // Split into two minis?
        if (!u.isMini && Math.random() < 0.4) {
          for (let j = 0; j < 2; j++) {
            const miniVX = (Math.random() - 0.5) * 4;
            const miniVY = (Math.random() - 0.5) * 4;
            ufos.push(new UFO(u.x, u.y, miniVX, miniVY, false, true));
          }
        }
      }
      break;
    }
  }
  hudScore.innerText = score;
}

canvas.addEventListener("click", e => handleClick(e.clientX, e.clientY));
canvas.addEventListener("touchstart", e => {
  const t = e.touches[0];
  handleClick(t.clientX, t.clientY);
});
canvas.addEventListener("touchmove", e => {
  const t = e.touches[0];
  handleClick(t.clientX, t.clientY);
});

function loop(ts) {
  if (!lastTime) lastTime = ts;
  const dt = (ts - lastTime) / 1000;
  lastTime = ts;

  ctx.clearRect(0, 0, canvas.width, canvas.height);

  spawnTimer += dt;
  if (spawnTimer > 1.2) { // faster spawns
    spawnTimer = 0;
    spawnChain();
  }

  const played = 60 - timeLeft;
  if (played >= nextBossAt) {
    spawnChain(true);
    nextBossAt += 60;
  }

  ufos.forEach(u => { u.update(dt); u.draw(); });
  effects.forEach((fx, i) => { fx.update(); fx.draw(); if (fx.a <= 0) effects.splice(i, 1); });

  timeLeft -= dt;
  hudTime.innerText = timeLeft.toFixed(1);

  if (timeLeft <= 0) {
    endGame();
    return;
  }

  requestAnimationFrame(loop);
}

function startGame(){
  ufos = []; effects = []; score = 0; reactionTimes = [];
  timeLeft = 15; lastTime = 0; spawnTimer = 0;
  nextBossAt = 60;
  hudScore.innerText = 0;
  hudTime.innerText = "15.0";
  overlay.style.display = "none";
  analysis.style.display = "none";
  requestAnimationFrame(loop);
}

function endGame(){
  overlay.style.display = "none";
  analysis.style.display = "flex";
  const avg = reactionTimes.length ? (reactionTimes.reduce((a,b)=>a+b)/reactionTimes.length).toFixed(0) : 0;
  statsTxt.innerHTML = `
    Final Score: ${score}<br>
    Clicks: ${reactionTimes.length}<br>
    Avg Reaction: ${avg} ms<br>
  `;
  const ctx2 = document.getElementById("reactionChart").getContext("2d");
  new Chart(ctx2, {
    type: "line",
    data: {
      labels: reactionTimes.map((_,i)=> i+1),
      datasets: [{
        label: "Reaction (ms)",
        data: reactionTimes,
        borderColor: "lime",
        fill: false
      }]
    },
    options:{scales:{y:{beginAtZero:true}}}
  });
}

function quitToHome(){
  window.location.href = "index.html";
}

startGame();
</script>
</body>
</html>
