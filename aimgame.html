
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>UFO Clicker</title>
  <style>
    html, body {
      margin: 0; padding: 0;
      overflow: hidden;
      font-family: Arial, sans-serif;
      background: black; color: white;
    }
    #gameCanvas { display: block; background: #000; touch-action: none; }
    #hud {
      position: absolute; top: 10px; left: 10px; z-index: 10;
    }
    #overlay, #analysisPanel {
      position: absolute; top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0,0,0,0.85);
      display: flex; align-items: center; justify-content: center;
      color: white; font-size: 20px; flex-direction: column;
      z-index: 20;
    }
    #overlay button, #analysisPanel button {
      margin-top: 20px; padding: 10px 20px; font-size: 16px;
    }
    #analysisPanel { display: none; }
    #chartContainer {
      width: 90%; max-width: 500px; margin-top: 20px;
    }
  </style>
</head>
<body>

<canvas id="gameCanvas"></canvas>

<div id="hud">
  Time: <span id="timeLeft">0.0</span>sÂ Â |Â Â Kills: <span id="score">0</span>
</div>

<div id="overlay">
  <div>ðŸ‘¾ Slash the UFOs to destroy them!</div>
  <div>Each splits into smaller ones. Clear all!</div>
  <button onclick="startGame()">Start Game</button>
</div>

<div id="analysisPanel">
  <h2>All UFOs Destroyed</h2>
  <p id="statsText"></p>
  <div id="chartContainer">
    <canvas id="reactionChart"></canvas>
  </div>
  <button onclick="startGame()">Play Again</button>
</div>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
const canvas = document.getElementById("gameCanvas"),
      ctx = canvas.getContext("2d");
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

let ufos = [], effects = [], trails = [], score = 0;
let timeStart = null, timeEnd = null;
let reactionTimes = [];

const MAX_DEPTH = 3;

const overlay = document.getElementById("overlay"),
      analysis = document.getElementById("analysisPanel"),
      statsTxt = document.getElementById("statsText"),
      hudTime = document.getElementById("timeLeft"),
      hudScore = document.getElementById("score");

class UFO {
  constructor(x, y, depth=0) {
    this.x = x;
    this.y = y;
    this.radius = 60 - depth * 12;
    this.depth = depth;
    this.spawnTime = performance.now();
    this.vx = (Math.random() * 2 - 1) * 2;
    this.vy = (Math.random() * 2 - 1) * 2;
    this.id = performance.now() + Math.random();
  }
  update() {
    this.x += this.vx;
    this.y += this.vy;
    if (this.x < this.radius || this.x > canvas.width - this.radius) this.vx *= -1;
    if (this.y < this.radius || this.y > canvas.height - this.radius) this.vy *= -1;
  }
  draw() {
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
    ctx.fillStyle = `hsl(${this.depth * 60}, 100%, 60%)`;
    ctx.fill();
    ctx.strokeStyle = "white";
    ctx.stroke();
  }
  isHit(x, y) {
    return Math.hypot(this.x - x, this.y - y) < this.radius;
  }
}

function spawnSplit(x, y, depth) {
  if (depth >= MAX_DEPTH) return;
  ufos.push(new UFO(x - 20, y - 20, depth + 1));
  ufos.push(new UFO(x + 20, y + 20, depth + 1));
}

function startGame() {
  ufos = [new UFO(canvas.width / 2, canvas.height / 2)];
  effects = []; trails = []; reactionTimes = [];
  score = 0; timeStart = performance.now(); timeEnd = null;
  hudScore.innerText = score;
  overlay.style.display = "none";
  analysis.style.display = "none";
  requestAnimationFrame(gameLoop);
}

function endGame() {
  timeEnd = performance.now();
  analysis.style.display = "flex";
  let duration = ((timeEnd - timeStart)/1000).toFixed(2);
  let avg = reactionTimes.length ? (reactionTimes.reduce((a,b)=>a+b)/reactionTimes.length).toFixed(0) : 0;
  statsTxt.innerHTML = `
    Time Taken: ${duration}s<br>
    UFOs Destroyed: ${score}<br>
    Avg Reaction Time: ${avg} ms
  `;
  const ctx2 = document.getElementById("reactionChart").getContext("2d");
  new Chart(ctx2, {
    type: "line",
    data: {
      labels: reactionTimes.map((_,i)=> i+1),
      datasets: [{
        label: "Reaction Time (ms)",
        data: reactionTimes,
        borderColor: "lime",
        fill: false
      }]
    },
    options:{scales:{y:{beginAtZero:true}}}
  });
}

function gameLoop(ts) {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Update/draw UFOs
  ufos.forEach(u => u.update());
  ufos.forEach(u => u.draw());

  // Update/draw trails
  trails.forEach(t => {
    ctx.beginPath();
    ctx.arc(t.x, t.y, 10, 0, Math.PI * 2);
    ctx.fillStyle = `rgba(255,255,255,${t.a})`;
    ctx.fill();
    t.a -= 0.05;
  });
  trails = trails.filter(t => t.a > 0);

  // Update timer
  if (timeStart) {
    let elapsed = ((performance.now() - timeStart)/1000).toFixed(1);
    hudTime.innerText = elapsed;
  }

  if (ufos.length === 0) {
    endGame();
    return;
  }

  requestAnimationFrame(gameLoop);
}

// Swipe/Touch detection
let isTouching = false;

function handleHit(x, y) {
  trails.push({x, y, a: 1});
  for (let i = ufos.length - 1; i >= 0; i--) {
    if (ufos[i].isHit(x, y)) {
      const t = performance.now() - ufos[i].spawnTime;
      reactionTimes.push(t);
      const depth = ufos[i].depth;
      const {x:ux, y:uy} = ufos[i];
      ufos.splice(i, 1);
      spawnSplit(ux, uy, depth);
      score++;
      hudScore.innerText = score;
    }
  }
}

canvas.addEventListener("mousedown", () => isTouching = true);
canvas.addEventListener("mouseup", () => isTouching = false);
canvas.addEventListener("mousemove", e => {
  if (isTouching) handleHit(e.clientX, e.clientY);
});

canvas.addEventListener("touchstart", e => {
  isTouching = true;
  for (let touch of e.touches) handleHit(touch.clientX, touch.clientY);
});
canvas.addEventListener("touchmove", e => {
  for (let touch of e.touches) handleHit(touch.clientX, touch.clientY);
});
canvas.addEventListener("touchend", () => isTouching = false);

</script>
</body>
</html>
