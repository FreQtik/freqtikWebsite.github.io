<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>UFO Clicker</title>
  <style>
    html, body {
      margin: 0; padding: 0;
      overflow: hidden;
      font-family: Arial, sans-serif;
      background: #000; color: #fff;
    }
    canvas { display: block; background: radial-gradient(circle at center, #111, #000); }
    #hud {
      position: absolute; top: 10px; left: 10px; z-index: 10;
    }
    #overlay, #analysisPanel {
      position: absolute; top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0,0,0,0.85);
      display: flex; align-items: center; justify-content: center;
      color: white; font-size: 20px; flex-direction: column;
      z-index: 20;
    }
    #overlay button, #analysisPanel button {
      margin-top: 20px; padding: 10px 20px; font-size: 16px;
    }
    #analysisPanel { display: none; }
    #chartContainer {
      width: 90%; max-width: 500px; margin-top: 20px;
    }
  </style>
</head>
<body>

<canvas id="gameCanvas"></canvas>

<div id="hud">
  Time: <span id="timeLeft">15.0</span>sÂ Â |Â Â Score: <span id="score">0</span>
</div>

<div id="overlay">
  <div>ðŸš€ Click the UFOs before they fly away!</div>
  <div>ðŸ‘¹ Boss appears every 60s, needs 3 hits!</div>
  <button id="startBtn">Start Game</button>
</div>

<div id="analysisPanel">
  <h2>Game Over</h2>
  <p id="statsText"></p>
  <div id="chartContainer">
    <canvas id="reactionChart"></canvas>
  </div>
  <button onclick="startGame()">Play Again</button>
  <button onclick="quitToHome()">Quit to Home</button>
</div>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
  const canvas = document.getElementById("gameCanvas"),
        ctx    = canvas.getContext("2d");
  canvas.width  = window.innerWidth;
  canvas.height = window.innerHeight;

  const hudTime  = document.getElementById("timeLeft"),
        hudScore = document.getElementById("score"),
        overlay  = document.getElementById("overlay"),
        analysis = document.getElementById("analysisPanel"),
        statsTxt = document.getElementById("statsText");

  const ufoPaths  = ["ufos/ufo1.png","ufos/ufo2.png","ufos/ufo3.png"],
        bossPath  = "ufos/boss.png";

  let ufos     = [],
      effects  = [],
      score    = 0,
      timeLeft = 15.0,
      lastTs   = 0,
      spawnAcc = 0,
      reactionTimes = [],
      nextBossAt = 60,
      gameRunning = false;

  class UFO {
    constructor(isBoss=false) {
      const edge = Math.random();
      if (edge < 0.4) { this.x = Math.random()*canvas.width; this.y = -80; }
      else if (edge < 0.7) { this.x = -80; this.y = Math.random()*canvas.height; }
      else { this.x = canvas.width+80; this.y = Math.random()*canvas.height; }

      this.isBoss = isBoss;
      this.size = isBoss ? 120 : 64;
      this.hp   = isBoss ? 3 : 1;
      this.speed = (1 + ufos.length*0.01) * (isBoss?0.8:1);
      this.time  = 0;

      let dx = Math.random()*2-1, dy = Math.random()*2-1;
      const mag = Math.hypot(dx,dy)||1; dx/=mag; dy/=mag;
      this.dx = dx; this.dy = dy;

      const types = ["linear","sine","tangent","circle"];
      this.type = types[Math.floor(Math.random()*types.length)];

      this.img = new Image();
      this.img.src = isBoss?bossPath:ufoPaths[Math.floor(Math.random()*ufoPaths.length)];
      this.id  = performance.now()+Math.random();
    }
    update(dt) {
      this.time += dt;
      let vx = this.dx * this.speed;
      let vy = this.dy * this.speed;
      switch(this.type) {
        case "sine": vx += Math.sin(this.time*5)*10; break;
        case "tangent": vy += Math.tan(this.time*2)*5; break;
        case "circle":
          vx += Math.cos(this.time*3)*8;
          vy += Math.sin(this.time*3)*8;
          break;
      }
      this.x += vx*dt*60;
      this.y += vy*dt*60;
    }
    draw() {
      ctx.drawImage(this.img, this.x-this.size/2, this.y-this.size/2, this.size, this.size);
    }
    hit(mx,my) {
      return Math.hypot(mx-this.x,my-this.y) < this.size/2;
    }
  }

  class Effect {
    constructor(x,y) { this.x=x; this.y=y; this.r=0; this.a=1; }
    update() { this.r+=4; this.a-=0.05; }
    draw() {
      ctx.save();
      ctx.globalAlpha = this.a;
      ctx.strokeStyle = "yellow";
      ctx.lineWidth   = 3;
      ctx.beginPath();
      ctx.arc(this.x,this.y,this.r,0,Math.PI*2);
      ctx.stroke();
      ctx.restore();
    }
  }

  function handleClick(cx,cy) {
    if (!gameRunning) return;
    const rect = canvas.getBoundingClientRect(),
          mx   = cx - rect.left,
          my   = cy - rect.top;
    for (let i=ufos.length-1;i>=0;i--) {
      let u=ufos[i];
      if (u.hit(mx,my)) {
        u.hp--;
        effects.push(new Effect(mx,my));
        if (u.hp<=0) {
          reactionTimes.push(performance.now()-u.time*1000);
          score += u.isBoss?10:1;
          ufos.splice(i,1);
          timeLeft += 0.5;
        }
        break;
      }
    }
    hudScore.innerText = score;
  }

  canvas.addEventListener("click", e => handleClick(e.clientX,e.clientY));
  canvas.addEventListener("touchstart", e => {
    let t=e.touches[0];
    handleClick(t.clientX,t.clientY);
  });

  function startGame(){
    ufos=[]; effects=[]; score=0; timeLeft=15.0; reactionTimes=[];
    spawnAcc=0; nextBossAt=60; gameRunning=true;
    overlay.style.display="none"; analysis.style.display="none";
    hudScore.innerText=score; hudTime.innerText=timeLeft.toFixed(1);
    lastTs=0;
    requestAnimationFrame(loop);
  }

  function endGame(){
    gameRunning=false;
    analysis.style.display="flex";
    let avg = reactionTimes.length
      ? (reactionTimes.reduce((a,b)=>a+b)/reactionTimes.length).toFixed(0)
      : 0;
    statsTxt.innerHTML = `
      Final Score: ${score}<br>
      Clicks: ${reactionTimes.length}<br>
      Avg Reaction: ${avg} ms
    `;
    new Chart(document.getElementById("reactionChart"), {
      type: "line",
      data: {
        labels: reactionTimes.map((_,i)=>i+1),
        datasets:[{
          label:"Reaction (ms)",
          data:reactionTimes,
          borderColor:"lime",
          fill:false
        }]
      },
      options:{scales:{y:{beginAtZero:true}}}
    });
  }

  function quitToHome(){
    window.location.href="index.html";
  }

  function loop(ts){
    if (!lastTs) lastTs=ts;
    let dt=(ts-lastTs)/1000;
    lastTs=ts;
    if (!gameRunning) return;

    ctx.clearRect(0,0,canvas.width,canvas.height);
    spawnAcc+=dt;
    if (spawnAcc>1){
      spawnAcc=0;
      ufos.push(new UFO());
    }

    const survived = 15 - timeLeft;
    if (survived>=nextBossAt){
      ufos.push(new UFO(true));
      nextBossAt+=60;
    }

    ufos.forEach(u=>{ u.update(dt); u.draw(); });
    ufos = ufos.filter(u=>
      u.x>-u.size && u.x<canvas.width+u.size &&
      u.y>-u.size && u.y<canvas.height+u.size
    );
    effects.forEach((fx,i)=>{
      fx.update(); fx.draw();
      if (fx.a<=0) effects.splice(i,1);
    });

    timeLeft-=dt;
    hudTime.innerText=timeLeft.toFixed(1);
    if (timeLeft<=0) { endGame(); return; }
    requestAnimationFrame(loop);
  }

  document.getElementById("startBtn").addEventListener("click", startGame);
</script>
</body>
</html>
